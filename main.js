/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.js
var main_exports = {};
__export(main_exports, {
  default: () => ReadingHighlighterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/ui/FloatingManager.js
var import_obsidian = require("obsidian");
var FloatingManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.containerEl = null;
    this.highlightBtn = null;
    this.tagBtn = null;
    this.removeBtn = null;
    this._handlers = [];
  }
  load() {
    this.createElements();
    this.registerEvents();
  }
  unload() {
    var _a;
    (_a = this.containerEl) == null ? void 0 : _a.remove();
    this.containerEl = null;
    this._handlers.forEach((cleanup) => cleanup());
    this._handlers = [];
  }
  createElements() {
    if (this.containerEl)
      return;
    this.containerEl = document.createElement("div");
    this.containerEl.addClass("reading-highlighter-float-container");
    this.highlightBtn = this.createButton("highlighter", "Subrayar selecci\xF3n");
    this.tagBtn = this.createButton("tag", "Etiquetar selecci\xF3n");
    this.removeBtn = this.createButton("minus", "Eliminar subrayado");
    this.removeBtn.addClass("reading-highlighter-remove-btn");
    this.containerEl.appendChild(this.highlightBtn);
    this.containerEl.appendChild(this.tagBtn);
    this.containerEl.appendChild(this.removeBtn);
    document.body.appendChild(this.containerEl);
  }
  createButton(iconName, label) {
    const btn = document.createElement("button");
    (0, import_obsidian.setIcon)(btn, iconName);
    btn.setAttribute("aria-label", label);
    btn.addClass("reading-highlighter-btn");
    return btn;
  }
  registerEvents() {
    const preventFocus = (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
    };
    const attachAction = (btn, actionInfo) => {
      const handler = (evt) => {
        preventFocus(evt);
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.getMode() === "preview") {
          this.plugin[actionInfo](view);
        }
        this.hide();
      };
      btn.addEventListener("mousedown", handler);
      btn.addEventListener("touchstart", handler, { passive: false });
    };
    if (this.highlightBtn)
      attachAction(this.highlightBtn, "highlightSelection");
    if (this.tagBtn)
      attachAction(this.tagBtn, "tagSelection");
    if (this.removeBtn)
      attachAction(this.removeBtn, "removeHighlightSelection");
  }
  handleSelection() {
    var _a;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view || view.getMode() !== "preview") {
      this.hide();
      return;
    }
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (snippet.trim() && sel && !sel.isCollapsed && sel.rangeCount > 0) {
      const range = sel.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      this.show(rect);
    } else {
      this.hide();
    }
  }
  show(rect) {
    if (!this.containerEl || !rect)
      return;
    this.containerEl.style.display = "flex";
    const containerHeight = 40;
    const containerWidth = 140;
    let top = rect.top - containerHeight - 10;
    let left = rect.left + rect.width / 2 - containerWidth / 2;
    if (top < 10)
      top = rect.bottom + 10;
    if (left < 10)
      left = 10;
    if (left + containerWidth > window.innerWidth - 10)
      left = window.innerWidth - containerWidth - 10;
    this.containerEl.style.top = `${top}px`;
    this.containerEl.style.left = `${left}px`;
  }
  hide() {
    if (this.containerEl) {
      this.containerEl.style.display = "none";
    }
  }
};

// src/core/SelectionLogic.js
var SelectionLogic = class {
  constructor(app) {
    this.app = app;
  }
  async locateSelection(processedFile, view, selectionSnippet, context = null, occurrenceIndex = 0) {
    const file = view.file;
    const raw = await this.app.vault.read(file);
    let candidates = this.findAllCandidates(raw, selectionSnippet);
    if (candidates.length === 0)
      return null;
    if (context) {
      const cleanContext = context.replace(/\s+/g, " ").trim();
      candidates = candidates.map((cand) => {
        let blockStart = raw.lastIndexOf("\n", cand.start);
        if (blockStart === -1)
          blockStart = 0;
        let blockEnd = raw.indexOf("\n", cand.end);
        if (blockEnd === -1)
          blockEnd = raw.length;
        const sourceBlock = raw.substring(blockStart, blockEnd).replace(/\s+/g, " ").trim();
        const score = this.calculateSimilarity(sourceBlock, cleanContext);
        return { ...cand, score };
      });
      const bestScore = Math.max(...candidates.map((c) => c.score));
      const threshold = bestScore * 0.85;
      const validCandidates = candidates.filter((c) => c.score >= threshold);
      if (occurrenceIndex >= 0 && occurrenceIndex < validCandidates.length) {
        const chosen = validCandidates[occurrenceIndex];
        return { raw, start: chosen.start, end: chosen.end };
      }
      if (validCandidates.length > 0) {
        return { raw, start: validCandidates[0].start, end: validCandidates[0].end };
      }
    }
    return { raw, start: candidates[0].start, end: candidates[0].end };
  }
  findAllCandidates(text, snippet) {
    const escaped = snippet.trim().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const pattern = escaped.replace(/\s+/g, "\\s+");
    const regex = new RegExp(pattern, "g");
    const candidates = [];
    let match;
    while ((match = regex.exec(text)) !== null) {
      candidates.push({
        start: match.index,
        end: match.index + match[0].length,
        text: match[0]
      });
    }
    return candidates;
  }
  calculateSimilarity(source, target) {
    if (source === target)
      return 1e3;
    const sourceTokens = source.split(" ");
    const targetTokens = target.split(" ");
    const sSet = new Set(sourceTokens);
    const tSet = new Set(targetTokens);
    let intersection = 0;
    for (const t of tSet) {
      if (sSet.has(t))
        intersection++;
    }
    const union = (/* @__PURE__ */ new Set([...sourceTokens, ...targetTokens])).size;
    const jaccard = union === 0 ? 0 : intersection / union;
    const lenDiff = Math.abs(source.length - target.length);
    const lenMultiplier = 1 / (1 + lenDiff * 0.1);
    return jaccard * 0.7 + lenMultiplier * 0.3;
  }
};

// src/modals/TagSuggestModal.js
var import_obsidian2 = require("obsidian");
var TagSuggestModal = class extends import_obsidian2.FuzzySuggestModal {
  constructor(plugin, onChoose) {
    super(plugin.app);
    this.plugin = plugin;
    this.onChoose = onChoose;
    this.setPlaceholder("Select or type to create a tag...");
  }
  getItems() {
    const tagCounts = this.app.metadataCache.getTags();
    return Object.keys(tagCounts).map((t) => ({ tag: t.substring(1), isNew: false }));
  }
  getItemText(item) {
    return item.tag;
  }
  getSuggestions(query) {
    const searchResults = super.getSuggestions(query);
    const cleanQuery = query.trim().replace(/\s+/g, "_");
    if (!cleanQuery)
      return searchResults;
    const exactMatch = searchResults.some((m) => m.item.tag.toLowerCase() === cleanQuery.toLowerCase());
    if (!exactMatch) {
      searchResults.unshift({
        item: { tag: cleanQuery, isNew: true },
        match: { score: 0, matches: [[0, cleanQuery.length]] }
      });
    }
    return searchResults;
  }
  renderSuggestion(match, el) {
    super.renderSuggestion(match, el);
    if (match.item.isNew) {
      el.createSpan({ text: " (Create new tag)", cls: "suggestion-aux" });
    }
  }
  onChooseItem(item, _evt) {
    this.onChoose(`#${item.tag}`);
  }
};

// src/utils/dom.js
function getScroll(view) {
  var _a;
  return typeof ((_a = view.previewMode) == null ? void 0 : _a.getScroll) === "function" ? view.previewMode.getScroll() : getFallbackScroll(view);
}
function applyScroll(view, pos) {
  var _a;
  if (typeof ((_a = view.previewMode) == null ? void 0 : _a.applyScroll) === "function") {
    view.previewMode.applyScroll(pos);
  } else {
    setFallbackScroll(view, pos);
  }
}
function getFallbackScroll(view) {
  var _a, _b;
  const el = (_a = view.containerEl.querySelector(".markdown-reading-view")) != null ? _a : view.containerEl.querySelector(".markdown-preview-view");
  return { x: 0, y: (_b = el == null ? void 0 : el.scrollTop) != null ? _b : 0 };
}
function setFallbackScroll(view, { y }) {
  var _a;
  const el = (_a = view.containerEl.querySelector(".markdown-reading-view")) != null ? _a : view.containerEl.querySelector(".markdown-preview-view");
  if (el)
    el.scrollTop = y;
}

// src/main.js
var ReadingHighlighterPlugin = class extends import_obsidian3.Plugin {
  onload() {
    this.floatingManager = new FloatingManager(this);
    this.logic = new SelectionLogic(this.app);
    this.addCommand({
      id: "highlight-selection-reading",
      name: "Highlight selection (Reading View)",
      checkCallback: (checking) => {
        const view = this.getActiveReadingView();
        if (!view)
          return false;
        if (checking)
          return true;
        this.highlightSelection(view);
        return true;
      }
    });
    this.registerDomEvent(document, "selectionchange", () => {
      this.floatingManager.handleSelection();
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.floatingManager.handleSelection();
      })
    );
    if (import_obsidian3.Platform.isMobile) {
      const btn = this.addRibbonIcon("highlighter", "Highlight Selection", () => {
        const view = this.getActiveReadingView();
        if (view)
          this.highlightSelection(view);
        else
          new import_obsidian3.Notice("Open a note in Reading View first.");
      });
      this.register(() => btn.remove());
    }
    this.floatingManager.load();
  }
  onunload() {
    this.floatingManager.unload();
  }
  getActiveReadingView() {
    const view = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
    return view && view.getMode() === "preview" ? view : null;
  }
  getSelectionContext() {
    var _a;
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0)
      return null;
    const range = sel.getRangeAt(0);
    let container = range.commonAncestorContainer;
    while (container && container.nodeType !== 1) {
      container = container.parentElement;
    }
    const viewContainer = (_a = this.getActiveReadingView()) == null ? void 0 : _a.containerEl;
    while (container && container !== viewContainer) {
      const tag = container.tagName.toLowerCase();
      if (["p", "li", "h1", "h2", "h3", "h4", "h5", "h6", "div", "blockquote", "pre"].includes(tag)) {
        return container;
      }
      container = container.parentElement;
    }
    if (container)
      return container;
    return null;
  }
  getSelectionOccurrence(view, contextElement) {
    if (!contextElement)
      return 0;
    const contextText = contextElement.innerText.trim();
    const tagName = contextElement.tagName.toLowerCase();
    const allElements = view.contentEl.querySelectorAll(tagName);
    let count = 0;
    let foundIndex = 0;
    for (let i = 0; i < allElements.length; i++) {
      const el = allElements[i];
      if (el.innerText.trim() === contextText) {
        if (el === contextElement) {
          foundIndex = count;
          break;
        }
        count++;
      }
    }
    return foundIndex;
  }
  async highlightSelection(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian3.Notice("No text selected.");
      return;
    }
    const scrollPos = getScroll(view);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian3.Notice("Could not locate selection in file.");
      return;
    }
    await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, "highlight");
    this.restoreScroll(view, scrollPos);
    sel == null ? void 0 : sel.removeAllRanges();
  }
  async tagSelection(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian3.Notice("No text selected.");
      return;
    }
    const scrollPos = getScroll(view);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian3.Notice("Could not locate selection in file.");
      return;
    }
    new TagSuggestModal(this, async (tag) => {
      var _a2;
      await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, "tag", tag);
      this.restoreScroll(view, scrollPos);
      (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
    }).open();
  }
  async removeHighlightSelection(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian3.Notice("Select highlighted text to remove.");
      return;
    }
    const scrollPos = getScroll(view);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian3.Notice("Could not locate selection in file.");
      return;
    }
    await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, "remove");
    new import_obsidian3.Notice("Highlighting removed.");
    this.restoreScroll(view, scrollPos);
    sel == null ? void 0 : sel.removeAllRanges();
  }
  async applyMarkdownModification(file, raw, start, end, mode, tag = "") {
    let expandedStart = start;
    let expandedEnd = end;
    while (expandedStart > 0 && raw.substring(expandedStart - 1, expandedStart) === "=") {
      expandedStart--;
    }
    while (expandedEnd < raw.length && raw.substring(expandedEnd, expandedEnd + 1) === "=") {
      expandedEnd++;
    }
    const selectedText = raw.substring(expandedStart, expandedEnd);
    const paragraphs = selectedText.split(/\n\s*\n/);
    const processedParagraphs = paragraphs.map((paragraph) => {
      if (!paragraph.trim())
        return paragraph;
      const lines = paragraph.split("\n");
      const processedLines = lines.map((line) => {
        const trimmed = line.trim();
        if (!trimmed)
          return line;
        const cleanLine = line.replace(/==/g, "");
        if (mode === "remove") {
          return cleanLine;
        }
        const matchIndent = cleanLine.match(/^(\s*)/);
        const indent = matchIndent ? matchIndent[0] : "";
        const contentAfterIndent = cleanLine.substring(indent.length);
        const prefixRegex = /^((?:#{1,6}\s+)|(?:[-*+]\s+)|(?:\d+\.\s+)|(?:>\s+)|(?:-\s\[[ x]\]\s+))/;
        const matchPrefix = contentAfterIndent.match(prefixRegex);
        let prefix = "";
        let content = contentAfterIndent;
        if (matchPrefix) {
          prefix = matchPrefix[0];
          content = contentAfterIndent.substring(prefix.length);
        }
        const tagStr = mode === "tag" && tag ? `${tag} ` : "";
        return `${indent}${prefix}${tagStr}==${content}==`;
      });
      return processedLines.join("\n");
    });
    const replaceBlock = processedParagraphs.join("\n\n");
    const newContent = raw.substring(0, expandedStart) + replaceBlock + raw.substring(expandedEnd);
    await this.app.vault.modify(file, newContent);
  }
  restoreScroll(view, pos) {
    requestAnimationFrame(() => {
      applyScroll(view, pos);
    });
  }
};
