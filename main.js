/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/export.js
var export_exports = {};
__export(export_exports, {
  exportHighlightsToMD: () => exportHighlightsToMD,
  getHighlightsFromContent: () => getHighlightsFromContent
});
async function exportHighlightsToMD(app, file) {
  const raw = await app.vault.read(file);
  const highlights = [];
  const markdownPattern = /==(.*?)==/gs;
  const htmlPattern = /<mark[^>]*>(.*?)<\/mark>/gs;
  let match;
  while ((match = markdownPattern.exec(raw)) !== null) {
    highlights.push({
      text: match[1].trim(),
      type: "markdown",
      position: match.index
    });
  }
  while ((match = htmlPattern.exec(raw)) !== null) {
    highlights.push({
      text: match[1].trim(),
      type: "html",
      position: match.index
    });
  }
  highlights.sort((a, b) => a.position - b.position);
  if (highlights.length === 0) {
    throw new Error("No highlights found in this file.");
  }
  const date = window.moment ? window.moment().format("YYYY-MM-DD HH:mm") : (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
  const exportContent = `# Highlights from [[${file.basename}]]

> Exported: ${date}
> Source: [[${file.path}]]
> Total highlights: ${highlights.length}

---

${highlights.map((h, i) => `${i + 1}. ${h.text}`).join("\n\n")}

---

*Exported by Reader Highlighter Tags*
`;
  let exportPath = `${file.parent.path}/${file.basename} - Highlights.md`;
  const existingFile = app.vault.getAbstractFileByPath(exportPath);
  if (existingFile) {
    const timestamp = window.moment ? window.moment().format("YYYYMMDD-HHmmss") : Date.now();
    exportPath = `${file.parent.path}/${file.basename} - Highlights ${timestamp}.md`;
  }
  await app.vault.create(exportPath, exportContent);
  return exportPath;
}
function getHighlightsFromContent(raw) {
  const highlights = [];
  const markdownPattern = /==(.*?)==/gs;
  const htmlPattern = /<mark[^>]*>(.*?)<\/mark>/gs;
  let match;
  while ((match = markdownPattern.exec(raw)) !== null) {
    const lineStart = raw.lastIndexOf("\n", match.index) + 1;
    const lineEnd = raw.indexOf("\n", match.index + match[0].length);
    const context = raw.substring(lineStart, lineEnd === -1 ? void 0 : lineEnd).trim();
    highlights.push({
      text: match[1].trim(),
      type: "markdown",
      position: match.index,
      context
    });
  }
  while ((match = htmlPattern.exec(raw)) !== null) {
    const lineStart = raw.lastIndexOf("\n", match.index) + 1;
    const lineEnd = raw.indexOf("\n", match.index + match[0].length);
    const context = raw.substring(lineStart, lineEnd === -1 ? void 0 : lineEnd).trim();
    const colorMatch = match[0].match(/background:\s*([^;>"]+)/);
    const color = colorMatch ? colorMatch[1].trim() : null;
    highlights.push({
      text: match[1].trim(),
      type: "html",
      position: match.index,
      context,
      color
    });
  }
  highlights.sort((a, b) => a.position - b.position);
  return highlights;
}
var init_export = __esm({
  "src/utils/export.js"() {
  }
});

// src/main.js
var main_exports = {};
__export(main_exports, {
  default: () => ReadingHighlighterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/ui/FloatingManager.js
var import_obsidian = require("obsidian");
var FloatingManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.containerEl = null;
    this.highlightBtn = null;
    this.tagBtn = null;
    this.removeBtn = null;
    this.quoteBtn = null;
    this.annotateBtn = null;
    this.colorButtons = [];
    this.paletteContainer = null;
    this._handlers = [];
    this.longPressTimer = null;
  }
  load() {
    this.createElements();
    this.registerEvents();
    if (import_obsidian.Platform.isMobile) {
      this.setupMobileGestures();
    }
  }
  unload() {
    var _a;
    (_a = this.containerEl) == null ? void 0 : _a.remove();
    this.containerEl = null;
    this._handlers.forEach((cleanup) => cleanup());
    this._handlers = [];
  }
  refresh() {
    if (this.containerEl) {
      this.containerEl.remove();
      this.containerEl = null;
    }
    this.colorButtons = [];
    this.createElements();
    this.registerEvents();
  }
  createElements() {
    if (this.containerEl)
      return;
    this.containerEl = document.createElement("div");
    this.containerEl.addClass("reading-highlighter-float-container");
    this.highlightBtn = this.createButton("highlighter", "Highlight selection");
    this.containerEl.appendChild(this.highlightBtn);
    if (this.plugin.settings.enableColorPalette) {
      this.paletteContainer = document.createElement("div");
      this.paletteContainer.addClass("reading-highlighter-palette");
      this.plugin.settings.colorPalette.forEach((item, index) => {
        const colorBtn = document.createElement("button");
        colorBtn.addClass("reading-highlighter-color-btn");
        colorBtn.style.backgroundColor = item.color;
        colorBtn.setAttribute("aria-label", item.name);
        colorBtn.setAttribute("data-color-index", index.toString());
        this.colorButtons.push(colorBtn);
        this.paletteContainer.appendChild(colorBtn);
      });
      this.containerEl.appendChild(this.paletteContainer);
    }
    if (this.plugin.settings.showTagButton) {
      this.tagBtn = this.createButton("tag", "Tag selection");
      this.containerEl.appendChild(this.tagBtn);
    }
    if (this.plugin.settings.showQuoteButton) {
      this.quoteBtn = this.createButton("quote", "Copy as quote");
      this.containerEl.appendChild(this.quoteBtn);
    }
    if (this.plugin.settings.enableAnnotations && this.plugin.settings.showAnnotationButton) {
      this.annotateBtn = this.createButton("message-square", "Add annotation");
      this.containerEl.appendChild(this.annotateBtn);
    }
    if (this.plugin.settings.showRemoveButton) {
      this.removeBtn = this.createButton("eraser", "Remove highlight");
      this.removeBtn.addClass("reading-highlighter-remove-btn");
      this.containerEl.appendChild(this.removeBtn);
    }
    document.body.appendChild(this.containerEl);
  }
  createButton(iconName, label) {
    const btn = document.createElement("button");
    (0, import_obsidian.setIcon)(btn, iconName);
    if (this.plugin.settings.showTooltips) {
      btn.setAttribute("aria-label", label);
    }
    btn.addClass("reading-highlighter-btn");
    return btn;
  }
  registerEvents() {
    const preventFocus = (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
    };
    const attachAction = (btn, actionName) => {
      if (!btn)
        return;
      const handler = (evt) => {
        preventFocus(evt);
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.getMode() === "preview") {
          this.plugin[actionName](view);
        }
        this.hide();
      };
      btn.addEventListener("mousedown", handler);
      btn.addEventListener("touchstart", handler, { passive: false });
    };
    attachAction(this.highlightBtn, "highlightSelection");
    attachAction(this.tagBtn, "tagSelection");
    attachAction(this.quoteBtn, "copyAsQuote");
    attachAction(this.annotateBtn, "annotateSelection");
    attachAction(this.removeBtn, "removeHighlightSelection");
    this.colorButtons.forEach((btn, index) => {
      const handler = (evt) => {
        preventFocus(evt);
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.getMode() === "preview") {
          this.plugin.applyColorByIndex(view, index);
        }
        this.hide();
      };
      btn.addEventListener("mousedown", handler);
      btn.addEventListener("touchstart", handler, { passive: false });
    });
  }
  setupMobileGestures() {
    document.addEventListener("touchstart", (e) => {
      this.longPressTimer = setTimeout(() => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        const sel = window.getSelection();
        if (view && view.getMode() === "preview" && (sel == null ? void 0 : sel.toString().trim())) {
          this.plugin.highlightSelection(view);
          this.hide();
        }
      }, 600);
    }, { passive: true });
    document.addEventListener("touchmove", () => {
      if (this.longPressTimer) {
        clearTimeout(this.longPressTimer);
        this.longPressTimer = null;
      }
    }, { passive: true });
    document.addEventListener("touchend", () => {
      if (this.longPressTimer) {
        clearTimeout(this.longPressTimer);
        this.longPressTimer = null;
      }
    }, { passive: true });
  }
  handleSelection() {
    var _a;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view || view.getMode() !== "preview") {
      this.hide();
      return;
    }
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (snippet.trim() && sel && !sel.isCollapsed && sel.rangeCount > 0) {
      const range = sel.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      this.show(rect);
    } else {
      this.hide();
    }
  }
  show(rect) {
    if (!this.containerEl || !rect)
      return;
    this.containerEl.style.display = "flex";
    this.containerEl.style.top = "";
    this.containerEl.style.bottom = "";
    this.containerEl.style.left = "";
    this.containerEl.style.right = "";
    this.containerEl.style.transform = "";
    this.containerEl.removeClass("reading-highlighter-vertical");
    const pos = this.plugin.settings.toolbarPosition || "text";
    if (pos === "text") {
      const containerHeight = 50;
      const containerWidth = this.plugin.settings.enableColorPalette ? 280 : 180;
      let top = rect.top - containerHeight - 10;
      let left = rect.left + rect.width / 2 - containerWidth / 2;
      if (top < 10)
        top = rect.bottom + 10;
      if (left < 10)
        left = 10;
      if (left + containerWidth > window.innerWidth - 10)
        left = window.innerWidth - containerWidth - 10;
      this.containerEl.style.top = `${top}px`;
      this.containerEl.style.left = `${left}px`;
    } else if (pos === "top") {
      this.containerEl.style.top = "80px";
      this.containerEl.style.left = "50%";
      this.containerEl.style.transform = "translateX(-50%)";
    } else if (pos === "bottom") {
      this.containerEl.style.bottom = "100px";
      this.containerEl.style.left = "50%";
      this.containerEl.style.transform = "translateX(-50%)";
    } else if (pos === "left") {
      this.containerEl.style.top = "50%";
      this.containerEl.style.left = "10px";
      this.containerEl.style.transform = "translateY(-50%)";
      this.containerEl.addClass("reading-highlighter-vertical");
    } else if (pos === "right") {
      this.containerEl.style.top = "50%";
      this.containerEl.style.right = "10px";
      this.containerEl.style.transform = "translateY(-50%)";
      this.containerEl.addClass("reading-highlighter-vertical");
    }
  }
  hide() {
    if (this.containerEl) {
      this.containerEl.style.display = "none";
    }
  }
};

// src/core/SelectionLogic.js
var SelectionLogic = class {
  constructor(app) {
    this.app = app;
  }
  async locateSelection(processedFile, view, selectionSnippet, context = null, occurrenceIndex = 0) {
    const file = view.file;
    const raw = await this.app.vault.read(file);
    let candidates = this.findAllCandidates(raw, selectionSnippet);
    if (candidates.length === 0) {
      candidates = this.findCandidatesStripped(raw, selectionSnippet);
    }
    if (candidates.length === 0)
      return null;
    if (context) {
      const cleanContext = context.replace(/\s+/g, " ").trim();
      candidates = candidates.map((cand) => {
        let blockStart = raw.lastIndexOf("\n", cand.start);
        if (blockStart === -1)
          blockStart = 0;
        let blockEnd = raw.indexOf("\n", cand.end);
        if (blockEnd === -1)
          blockEnd = raw.length;
        const sourceBlock = raw.substring(blockStart, blockEnd).replace(/\s+/g, " ").trim();
        const score = this.calculateSimilarity(sourceBlock, cleanContext);
        return { ...cand, score };
      });
      const bestScore = Math.max(...candidates.map((c) => c.score));
      const threshold = bestScore * 0.85;
      const validCandidates = candidates.filter((c) => c.score >= threshold);
      if (occurrenceIndex >= 0 && occurrenceIndex < validCandidates.length) {
        const chosen = validCandidates[occurrenceIndex];
        return { raw, start: chosen.start, end: chosen.end };
      }
      if (validCandidates.length > 0) {
        return { raw, start: validCandidates[0].start, end: validCandidates[0].end };
      }
    }
    return { raw, start: candidates[0].start, end: candidates[0].end };
  }
  findAllCandidates(text, snippet) {
    const escaped = snippet.trim().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const pattern = escaped.replace(/\s+/g, "\\s+");
    const regex = new RegExp(pattern, "g");
    const candidates = [];
    let match;
    while ((match = regex.exec(text)) !== null) {
      candidates.push({
        start: match.index,
        end: match.index + match[0].length,
        text: match[0]
      });
    }
    return candidates;
  }
  findCandidatesStripped(text, snippet) {
    const map = [];
    let strippedRaw = "";
    const tokenRegex = /(\[(?:[^\]]+)\]\([^)]+\))|(\[\[(?:[^\]]+)\]\])|(\*|_|==|~~|<[^>]+>)/g;
    let lastIndex = 0;
    let match;
    while ((match = tokenRegex.exec(text)) !== null) {
      for (let i = lastIndex; i < match.index; i++) {
        map.push(i);
        strippedRaw += text[i];
      }
      const fullMatch = match[0];
      if (match[1]) {
        const closingBracket = fullMatch.indexOf("](");
        if (closingBracket !== -1) {
          const linkTextStart = match.index + 1;
          const linkTextEnd = match.index + closingBracket;
          for (let i = linkTextStart; i < linkTextEnd; i++) {
            map.push(i);
            strippedRaw += text[i];
          }
        }
      } else if (match[2]) {
        const inner = fullMatch.substring(2, fullMatch.length - 2);
        const pipeIndex = inner.indexOf("|");
        let visibleStart, visibleEnd;
        if (pipeIndex !== -1) {
          visibleStart = match.index + 2 + pipeIndex + 1;
          visibleEnd = match.index + fullMatch.length - 2;
        } else {
          visibleStart = match.index + 2;
          visibleEnd = match.index + fullMatch.length - 2;
        }
        for (let i = visibleStart; i < visibleEnd; i++) {
          map.push(i);
          strippedRaw += text[i];
        }
      } else {
      }
      lastIndex = tokenRegex.lastIndex;
    }
    for (let i = lastIndex; i < text.length; i++) {
      map.push(i);
      strippedRaw += text[i];
    }
    const escaped = snippet.trim().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const pattern = escaped.replace(/\s+/g, "\\s+");
    const regex = new RegExp(pattern, "g");
    const candidates = [];
    let strippedMatch;
    while ((strippedMatch = regex.exec(strippedRaw)) !== null) {
      const strippedStart = strippedMatch.index;
      const strippedEnd = strippedMatch.index + strippedMatch[0].length;
      const rawStart = map[strippedStart];
      let rawEnd;
      if (strippedEnd < map.length) {
        rawEnd = map[strippedEnd];
      } else {
        rawEnd = map[strippedEnd - 1] + 1;
      }
      candidates.push({
        start: rawStart,
        end: rawEnd,
        text: text.substring(rawStart, rawEnd)
      });
    }
    return candidates;
  }
  calculateSimilarity(source, target) {
    if (source === target)
      return 1e3;
    const sourceTokens = source.split(" ");
    const targetTokens = target.split(" ");
    const sSet = new Set(sourceTokens);
    const tSet = new Set(targetTokens);
    let intersection = 0;
    for (const t of tSet) {
      if (sSet.has(t))
        intersection++;
    }
    const union = (/* @__PURE__ */ new Set([...sourceTokens, ...targetTokens])).size;
    const jaccard = union === 0 ? 0 : intersection / union;
    const lenDiff = Math.abs(source.length - target.length);
    const lenMultiplier = 1 / (1 + lenDiff * 0.1);
    return jaccard * 0.7 + lenMultiplier * 0.3;
  }
};

// src/modals/TagSuggestModal.js
var import_obsidian2 = require("obsidian");
var TagSuggestModal = class extends import_obsidian2.Modal {
  constructor(plugin, onChoose) {
    super(plugin.app);
    this.plugin = plugin;
    this.onChoose = onChoose;
    this.selectedTags = /* @__PURE__ */ new Set();
    this.suggestions = [];
    this.query = "";
    this.suggestionEl = null;
    this.selectedContainer = null;
    this.smartSuggestionEl = null;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("reading-highlighter-tag-modal");
    contentEl.createEl("h2", { text: "Add Tags" });
    if (this.plugin.settings.enableSmartTagSuggestions) {
      const smartTags = this.getSuggestedTags();
      if (smartTags.length > 0) {
        this.smartSuggestionEl = contentEl.createDiv({ cls: "smart-suggestions-container" });
        this.smartSuggestionEl.createEl("span", { text: "Suggestions: ", cls: "smart-suggestions-label" });
        const chipsContainer = this.smartSuggestionEl.createDiv({ cls: "smart-suggestions-chips" });
        smartTags.forEach((tag) => {
          const chip = chipsContainer.createEl("button", {
            text: `#${tag}`,
            cls: "smart-suggestion-chip"
          });
          chip.onclick = () => {
            this.toggleTag(tag);
            chip.addClass("selected");
          };
        });
      }
    }
    this.selectedContainer = contentEl.createDiv({ cls: "selected-tags-container" });
    this.updateSelectedView();
    const inputContainer = contentEl.createDiv({ cls: "tag-search-input-container" });
    const input = inputContainer.createEl("input", {
      type: "text",
      cls: "tag-search-input",
      attr: { placeholder: "Search or create tag..." }
    });
    setTimeout(() => input.focus(), 50);
    this.suggestionEl = contentEl.createDiv({ cls: "tag-suggestions-list" });
    const footer = contentEl.createDiv({ cls: "modal-footer" });
    const doneBtn = footer.createEl("button", { text: "Done", cls: "mod-cta" });
    doneBtn.onclick = () => this.submit();
    const tagCounts = this.app.metadataCache.getTags();
    this.allTags = Object.keys(tagCounts).map((t) => t.substring(1));
    input.addEventListener("input", (e) => {
      this.query = e.target.value;
      this.renderSuggestions(this.query);
    });
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        if (this.query.trim()) {
          this.toggleTag(this.query.trim());
          this.query = "";
          input.value = "";
          this.renderSuggestions("");
        }
      } else if (e.key === "Escape") {
        this.close();
      }
    });
    this.renderSuggestions("");
  }
  /**
   * Get smart tag suggestions based on:
   * 1. Recent tags (MRU)
   * 2. Current folder name
   * 3. Frontmatter tags
   */
  getSuggestedTags() {
    var _a, _b, _c;
    const suggestions = [];
    if (((_a = this.plugin.settings.recentTags) == null ? void 0 : _a.length) > 0) {
      suggestions.push(...this.plugin.settings.recentTags.slice(0, 5));
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (((_b = activeFile == null ? void 0 : activeFile.parent) == null ? void 0 : _b.name) && activeFile.parent.name !== "/") {
      const folderTag = activeFile.parent.name.toLowerCase().replace(/\s+/g, "-").replace(/[^a-z0-9-_]/g, "");
      if (folderTag && !suggestions.includes(folderTag)) {
        suggestions.push(folderTag);
      }
    }
    if (activeFile) {
      const cache = this.app.metadataCache.getFileCache(activeFile);
      if ((_c = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _c.tags) {
        const fmTags = Array.isArray(cache.frontmatter.tags) ? cache.frontmatter.tags : [cache.frontmatter.tags];
        fmTags.forEach((tag) => {
          const cleanTag = String(tag).replace(/^#/, "");
          if (cleanTag && !suggestions.includes(cleanTag)) {
            suggestions.push(cleanTag);
          }
        });
      }
    }
    return [...new Set(suggestions)].slice(0, 8);
  }
  renderSuggestions(query) {
    this.suggestionEl.empty();
    const cleanQuery = query.toLowerCase().replace(/\s+/g, "_");
    let matches = this.allTags.filter((t) => t.toLowerCase().includes(cleanQuery));
    const isExact = matches.some((t) => t.toLowerCase() === cleanQuery);
    if (cleanQuery && !isExact) {
      this.renderItem(cleanQuery, true);
    }
    matches.slice(0, 50).forEach((tag) => {
      if (!this.selectedTags.has(tag)) {
        this.renderItem(tag, false);
      }
    });
  }
  renderItem(tag, isNew) {
    const el = this.suggestionEl.createDiv({ cls: "suggestion-item" });
    el.createSpan({ text: isNew ? `#${tag}` : `#${tag}` });
    if (isNew) {
      el.createSpan({ text: " (Create new)", cls: "suggestion-note" });
    }
    el.addEventListener("click", () => {
      this.toggleTag(tag);
      this.query = "";
      this.contentEl.querySelector(".tag-search-input").value = "";
      this.contentEl.querySelector(".tag-search-input").focus();
      this.renderSuggestions("");
    });
  }
  toggleTag(tag) {
    const cleanTag = tag.replace(/^#/, "").replace(/\s+/g, "_");
    if (this.selectedTags.has(cleanTag)) {
      this.selectedTags.delete(cleanTag);
    } else {
      this.selectedTags.add(cleanTag);
    }
    this.updateSelectedView();
  }
  updateSelectedView() {
    this.selectedContainer.empty();
    if (this.selectedTags.size === 0) {
      this.selectedContainer.createSpan({
        text: "No tags selected",
        cls: "no-tags-hint"
      });
      return;
    }
    this.selectedTags.forEach((tag) => {
      const chip = this.selectedContainer.createDiv({ cls: "tag-chip" });
      chip.createSpan({ text: `#${tag}` });
      const close = chip.createSpan({ cls: "tag-chip-close", text: "\xD7" });
      close.onclick = (e) => {
        e.stopPropagation();
        this.toggleTag(tag);
      };
    });
  }
  submit() {
    const result = Array.from(this.selectedTags).map((t) => `#${t}`).join(" ");
    this.onChoose(result);
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/AnnotationModal.js
var import_obsidian3 = require("obsidian");
var AnnotationModal = class extends import_obsidian3.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.comment = "";
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("reading-highlighter-annotation-modal");
    contentEl.createEl("h2", { text: "Add Annotation" });
    contentEl.createEl("p", {
      text: "Your comment will be added as a footnote at the bottom of the document.",
      cls: "annotation-description"
    });
    const textArea = new import_obsidian3.TextAreaComponent(contentEl);
    textArea.inputEl.addClass("annotation-textarea");
    textArea.setPlaceholder("Enter your annotation...");
    textArea.onChange((value) => {
      this.comment = value;
    });
    setTimeout(() => textArea.inputEl.focus(), 50);
    textArea.inputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        this.submit();
      }
    });
    const footer = contentEl.createDiv({ cls: "modal-footer" });
    const cancelBtn = footer.createEl("button", { text: "Cancel" });
    cancelBtn.onclick = () => this.close();
    const submitBtn = footer.createEl("button", { text: "Add Annotation", cls: "mod-cta" });
    submitBtn.onclick = () => this.submit();
  }
  submit() {
    if (this.comment.trim()) {
      this.onSubmit(this.comment.trim());
    }
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/HighlightNavigator.js
var import_obsidian4 = require("obsidian");
init_export();
var HIGHLIGHT_NAVIGATOR_VIEW = "highlight-navigator";
var HighlightNavigatorView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.highlights = [];
    this.currentFile = null;
  }
  getViewType() {
    return HIGHLIGHT_NAVIGATOR_VIEW;
  }
  getDisplayText() {
    return "Highlights";
  }
  getIcon() {
    return "highlighter";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("highlight-navigator-container");
    const header = container.createDiv({ cls: "highlight-navigator-header" });
    header.createEl("h4", { text: "Highlights" });
    const refreshBtn = header.createEl("button", { cls: "clickable-icon" });
    refreshBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>`;
    refreshBtn.setAttribute("aria-label", "Refresh");
    refreshBtn.onclick = () => this.refresh();
    this.contentEl = container.createDiv({ cls: "highlight-navigator-content" });
    const footer = container.createDiv({ cls: "highlight-navigator-footer" });
    const exportBtn = footer.createEl("button", { text: "Export to MD", cls: "mod-cta" });
    exportBtn.onclick = () => this.exportHighlights();
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.refresh();
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        if (this.currentFile && file.path === this.currentFile.path) {
          this.refresh();
        }
      })
    );
    this.refresh();
  }
  async refresh() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (!view || !view.file) {
      this.showEmpty("Open a note to see its highlights.");
      return;
    }
    this.currentFile = view.file;
    try {
      const raw = await this.app.vault.read(view.file);
      this.highlights = getHighlightsFromContent(raw);
      this.renderHighlights();
    } catch (err) {
      this.showEmpty("Error loading highlights.");
      console.error(err);
    }
  }
  showEmpty(message) {
    this.contentEl.empty();
    this.contentEl.createDiv({ cls: "highlight-navigator-empty", text: message });
  }
  renderHighlights() {
    this.contentEl.empty();
    if (this.highlights.length === 0) {
      this.showEmpty("No highlights in this file.");
      return;
    }
    const stats = this.contentEl.createDiv({ cls: "highlight-navigator-stats" });
    stats.createSpan({ text: `${this.highlights.length} highlight${this.highlights.length !== 1 ? "s" : ""}` });
    const list = this.contentEl.createDiv({ cls: "highlight-navigator-list" });
    this.highlights.forEach((highlight, index) => {
      const item = list.createDiv({ cls: "highlight-navigator-item" });
      if (highlight.color) {
        const colorDot = item.createSpan({ cls: "highlight-color-dot" });
        colorDot.style.backgroundColor = highlight.color;
      } else {
        const colorDot = item.createSpan({ cls: "highlight-color-dot highlight-default" });
      }
      const textPreview = highlight.text.length > 80 ? highlight.text.substring(0, 80) + "..." : highlight.text;
      const textEl = item.createSpan({ cls: "highlight-text", text: textPreview });
      item.createSpan({ cls: "highlight-number", text: `${index + 1}` });
      item.onclick = () => this.jumpToHighlight(highlight);
    });
  }
  async jumpToHighlight(highlight) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (!view)
      return;
    const previewEl = view.containerEl.querySelector(".markdown-reading-view") || view.containerEl.querySelector(".markdown-preview-view");
    if (!previewEl)
      return;
    const walker = document.createTreeWalker(previewEl, NodeFilter.SHOW_TEXT);
    let node;
    while (node = walker.nextNode()) {
      if (node.textContent.includes(highlight.text.substring(0, 20))) {
        const parent = node.parentElement;
        if (parent) {
          parent.scrollIntoView({ behavior: "smooth", block: "center" });
          parent.addClass("highlight-flash");
          setTimeout(() => parent.removeClass("highlight-flash"), 1e3);
          break;
        }
      }
    }
  }
  async exportHighlights() {
    if (!this.currentFile)
      return;
    try {
      const { exportHighlightsToMD: exportHighlightsToMD2 } = await Promise.resolve().then(() => (init_export(), export_exports));
      const exportPath = await exportHighlightsToMD2(this.app, this.currentFile);
      const exportFile = this.app.vault.getAbstractFileByPath(exportPath);
      if (exportFile) {
        await this.app.workspace.getLeaf().openFile(exportFile);
      }
    } catch (err) {
      console.error(err);
    }
  }
  async onClose() {
  }
};

// src/utils/dom.js
function getScroll(view) {
  var _a;
  return typeof ((_a = view.previewMode) == null ? void 0 : _a.getScroll) === "function" ? view.previewMode.getScroll() : getFallbackScroll(view);
}
function applyScroll(view, pos) {
  var _a;
  if (typeof ((_a = view.previewMode) == null ? void 0 : _a.applyScroll) === "function") {
    view.previewMode.applyScroll(pos);
  } else {
    setFallbackScroll(view, pos);
  }
}
function getFallbackScroll(view) {
  var _a, _b;
  const el = (_a = view.containerEl.querySelector(".markdown-reading-view")) != null ? _a : view.containerEl.querySelector(".markdown-preview-view");
  return { x: 0, y: (_b = el == null ? void 0 : el.scrollTop) != null ? _b : 0 };
}
function setFallbackScroll(view, { y }) {
  var _a;
  const el = (_a = view.containerEl.querySelector(".markdown-reading-view")) != null ? _a : view.containerEl.querySelector(".markdown-preview-view");
  if (el)
    el.scrollTop = y;
}

// src/main.js
init_export();
var DEFAULT_SETTINGS = {
  toolbarPosition: "right",
  enableColorHighlighting: false,
  highlightColor: "",
  defaultTagPrefix: "",
  enableHaptics: true,
  showTagButton: true,
  showRemoveButton: true,
  showQuoteButton: true,
  // NEW: Color Palette (optional, disabled by default = use == highlight)
  enableColorPalette: false,
  colorPalette: [
    { name: "Yellow", color: "#FFEE58", tag: "" },
    { name: "Blue", color: "#64B5F6", tag: "" },
    { name: "Green", color: "#81C784", tag: "" },
    { name: "Red", color: "#EF5350", tag: "" },
    { name: "Purple", color: "#BA68C8", tag: "" }
  ],
  // NEW: Highlight Styles (presets with color + tag)
  highlightStyles: [
    { name: "Important", color: "#FFEE58", tag: "important" },
    { name: "Question", color: "#64B5F6", tag: "question" },
    { name: "Definition", color: "#81C784", tag: "definition" }
  ],
  // NEW: Quote Template
  quoteTemplate: "> {{text}}\n>\n> \u2014 [[{{file}}]]",
  // NEW: Annotations
  enableAnnotations: true,
  showAnnotationButton: true,
  // NEW: Reading Progress
  enableReadingProgress: true,
  readingPositions: {},
  // NEW: Smart Tags
  enableSmartTagSuggestions: true,
  recentTags: [],
  maxRecentTags: 10,
  // NEW: Navigator
  showNavigatorButton: true,
  // NEW: Tooltips (disabled by default)
  showTooltips: false
};
var ReadingHighlighterPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.floatingManager = new FloatingManager(this);
    this.logic = new SelectionLogic(this.app);
    this.lastModification = null;
    this.lastScrollPosition = null;
    this.registerView(
      HIGHLIGHT_NAVIGATOR_VIEW,
      (leaf) => new HighlightNavigatorView(leaf, this)
    );
    this.addSettingTab(new ReadingHighlighterSettingTab(this.app, this));
    this.registerCommands();
    this.registerDomEvent(document, "selectionchange", () => {
      this.floatingManager.handleSelection();
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.floatingManager.handleSelection();
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (this.settings.enableReadingProgress) {
          this.saveReadingProgress();
        }
      })
    );
    if (import_obsidian5.Platform.isMobile) {
      const btn = this.addRibbonIcon("highlighter", "Highlight Selection", () => {
        const view = this.getActiveReadingView();
        if (view)
          this.highlightSelection(view);
        else
          new import_obsidian5.Notice("Open a note in Reading View first.");
      });
      this.register(() => btn.remove());
    }
    this.addRibbonIcon("list", "Highlight Navigator", () => {
      this.activateNavigatorView();
    });
    this.floatingManager.load();
  }
  registerCommands() {
    this.addCommand({
      id: "highlight-selection-reading",
      name: "Highlight selection (Reading View)",
      checkCallback: (checking) => {
        const view = this.getActiveReadingView();
        if (!view)
          return false;
        if (checking)
          return true;
        this.highlightSelection(view);
        return true;
      }
    });
    this.addCommand({
      id: "tag-selection",
      name: "Tag selection (Reading View)",
      checkCallback: (checking) => {
        const view = this.getActiveReadingView();
        if (!view)
          return false;
        if (checking)
          return true;
        this.tagSelection(view);
        return true;
      }
    });
    this.addCommand({
      id: "annotate-selection",
      name: "Add annotation to selection (Reading View)",
      checkCallback: (checking) => {
        const view = this.getActiveReadingView();
        if (!view)
          return false;
        if (checking)
          return true;
        this.annotateSelection(view);
        return true;
      }
    });
    this.addCommand({
      id: "copy-as-quote",
      name: "Copy selection as quote (Reading View)",
      checkCallback: (checking) => {
        const view = this.getActiveReadingView();
        if (!view)
          return false;
        if (checking)
          return true;
        this.copyAsQuote(view);
        return true;
      }
    });
    this.addCommand({
      id: "remove-highlight",
      name: "Remove highlight from selection (Reading View)",
      checkCallback: (checking) => {
        const view = this.getActiveReadingView();
        if (!view)
          return false;
        if (checking)
          return true;
        this.removeHighlightSelection(view);
        return true;
      }
    });
    this.addCommand({
      id: "undo-last-highlight",
      name: "Undo last highlight",
      callback: () => {
        this.undoLastHighlight();
      }
    });
    this.addCommand({
      id: "open-highlight-navigator",
      name: "Open highlight navigator",
      callback: () => {
        this.activateNavigatorView();
      }
    });
    this.addCommand({
      id: "export-highlights",
      name: "Export highlights to new note",
      checkCallback: (checking) => {
        const view = this.getActiveReadingView();
        if (!view)
          return false;
        if (checking)
          return true;
        this.exportHighlights(view);
        return true;
      }
    });
    this.addCommand({
      id: "remove-all-highlights",
      name: "Remove all highlights from note",
      checkCallback: (checking) => {
        const view = this.getActiveReadingView();
        if (!view)
          return false;
        if (checking)
          return true;
        this.removeAllHighlights(view);
        return true;
      }
    });
    this.addCommand({
      id: "resume-reading",
      name: "Resume reading (jump to last position)",
      checkCallback: (checking) => {
        const view = this.getActiveReadingView();
        if (!view)
          return false;
        if (checking)
          return true;
        this.resumeReading(view);
        return true;
      }
    });
    for (let i = 0; i < 5; i++) {
      this.addCommand({
        id: `apply-color-${i + 1}`,
        name: `Apply highlight color ${i + 1}`,
        checkCallback: (checking) => {
          if (!this.settings.enableColorPalette)
            return false;
          const view = this.getActiveReadingView();
          if (!view)
            return false;
          if (checking)
            return true;
          this.applyColorByIndex(view, i);
          return true;
        }
      });
    }
  }
  onunload() {
    this.floatingManager.unload();
    this.app.workspace.detachLeavesOfType(HIGHLIGHT_NAVIGATOR_VIEW);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.floatingManager.refresh();
  }
  getActiveReadingView() {
    const view = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
    return view && view.getMode() === "preview" ? view : null;
  }
  getSelectionContext() {
    var _a;
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0)
      return null;
    const range = sel.getRangeAt(0);
    let container = range.commonAncestorContainer;
    while (container && container.nodeType !== 1) {
      container = container.parentElement;
    }
    const viewContainer = (_a = this.getActiveReadingView()) == null ? void 0 : _a.containerEl;
    while (container && container !== viewContainer) {
      const tag = container.tagName.toLowerCase();
      if (["p", "li", "h1", "h2", "h3", "h4", "h5", "h6", "div", "blockquote", "pre"].includes(tag)) {
        return container;
      }
      container = container.parentElement;
    }
    if (container)
      return container;
    return null;
  }
  getSelectionOccurrence(view, contextElement) {
    if (!contextElement)
      return 0;
    const contextText = contextElement.innerText.trim();
    const tagName = contextElement.tagName.toLowerCase();
    const allElements = view.contentEl.querySelectorAll(tagName);
    let count = 0;
    let foundIndex = 0;
    for (let i = 0; i < allElements.length; i++) {
      const el = allElements[i];
      if (el.innerText.trim() === contextText) {
        if (el === contextElement) {
          foundIndex = count;
          break;
        }
        count++;
      }
    }
    return foundIndex;
  }
  // Save state for undo
  async saveUndoState(file) {
    this.lastModification = {
      file,
      original: await this.app.vault.read(file)
    };
  }
  // Undo last highlight
  async undoLastHighlight() {
    if (!this.lastModification) {
      new import_obsidian5.Notice("Nothing to undo.");
      return;
    }
    try {
      await this.app.vault.modify(
        this.lastModification.file,
        this.lastModification.original
      );
      new import_obsidian5.Notice("Undone last highlight.");
      this.lastModification = null;
    } catch (err) {
      new import_obsidian5.Notice("Failed to undo.");
      console.error(err);
    }
  }
  async highlightSelection(view) {
    var _a, _b;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian5.Notice("No text selected.");
      return;
    }
    const scrollPos = getScroll(view);
    await this.saveUndoState(view.file);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian5.Notice("Could not locate selection in file.");
      return;
    }
    let mode = "highlight";
    let payload = "";
    if (this.settings.enableColorHighlighting && this.settings.highlightColor) {
      mode = "color";
      payload = this.settings.highlightColor;
    }
    await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, mode, payload);
    this.restoreScroll(view, scrollPos);
    sel == null ? void 0 : sel.removeAllRanges();
    if (this.settings.enableHaptics && import_obsidian5.Platform.isMobile) {
      (_b = navigator.vibrate) == null ? void 0 : _b.call(navigator, 10);
    }
    new import_obsidian5.Notice("Highlighted!");
  }
  // Apply color by palette index
  async applyColorByIndex(view, index) {
    if (index < 0 || index >= this.settings.colorPalette.length)
      return;
    const palette = this.settings.colorPalette[index];
    await this.applyColorHighlight(view, palette.color, palette.tag);
  }
  async tagSelection(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian5.Notice("No text selected.");
      return;
    }
    const scrollPos = getScroll(view);
    await this.saveUndoState(view.file);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian5.Notice("Could not locate selection in file.");
      return;
    }
    new TagSuggestModal(this, async (tag) => {
      var _a2;
      if (tag && this.settings.enableSmartTagSuggestions) {
        this.addRecentTag(tag);
      }
      await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, "tag", tag);
      this.restoreScroll(view, scrollPos);
      (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
    }).open();
  }
  // Add to recent tags
  addRecentTag(tag) {
    const cleanTag = tag.replace(/^#/, "").trim();
    if (!cleanTag)
      return;
    this.settings.recentTags = this.settings.recentTags.filter((t) => t !== cleanTag);
    this.settings.recentTags.unshift(cleanTag);
    if (this.settings.recentTags.length > this.settings.maxRecentTags) {
      this.settings.recentTags = this.settings.recentTags.slice(0, this.settings.maxRecentTags);
    }
    this.saveSettings();
  }
  // Annotate selection with footnote
  async annotateSelection(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian5.Notice("No text selected.");
      return;
    }
    const scrollPos = getScroll(view);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian5.Notice("Could not locate selection in file.");
      return;
    }
    new AnnotationModal(this.app, async (comment) => {
      var _a2;
      if (!comment.trim())
        return;
      await this.saveUndoState(view.file);
      await this.applyAnnotation(view.file, result.raw, result.start, result.end, comment);
      this.restoreScroll(view, scrollPos);
      (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
      new import_obsidian5.Notice("Annotation added!");
    }).open();
  }
  // Apply annotation as footnote
  async applyAnnotation(file, raw, start, end, comment) {
    const footnotePattern = /\[\^(\d+)\]/g;
    let maxNumber = 0;
    let match;
    while ((match = footnotePattern.exec(raw)) !== null) {
      const num = parseInt(match[1]);
      if (num > maxNumber)
        maxNumber = num;
    }
    const footnoteNum = maxNumber + 1;
    const beforeSelection = raw.substring(0, end);
    const afterSelection = raw.substring(end);
    const footnoteRef = `[^${footnoteNum}]`;
    const footnoteDef = `

[^${footnoteNum}]: ${comment}`;
    let newContent = beforeSelection + footnoteRef + afterSelection;
    newContent = newContent.trimEnd() + footnoteDef + "\n";
    await this.app.vault.modify(file, newContent);
  }
  async removeHighlightSelection(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian5.Notice("Select highlighted text to remove.");
      return;
    }
    const scrollPos = getScroll(view);
    await this.saveUndoState(view.file);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian5.Notice("Could not locate selection in file.");
      return;
    }
    await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, "remove");
    new import_obsidian5.Notice("Highlighting removed.");
    this.restoreScroll(view, scrollPos);
    sel == null ? void 0 : sel.removeAllRanges();
  }
  // Remove all highlights from file
  async removeAllHighlights(view) {
    await this.saveUndoState(view.file);
    let raw = await this.app.vault.read(view.file);
    raw = raw.replace(/==(.*?)==/g, "$1");
    raw = raw.replace(/<mark[^>]*>(.*?)<\/mark>/g, "$1");
    await this.app.vault.modify(view.file, raw);
    new import_obsidian5.Notice("All highlights removed.");
  }
  // Export highlights to new MD file
  async exportHighlights(view) {
    try {
      const exportPath = await exportHighlightsToMD(this.app, view.file);
      new import_obsidian5.Notice(`Highlights exported to ${exportPath}`);
      const exportFile = this.app.vault.getAbstractFileByPath(exportPath);
      if (exportFile) {
        await this.app.workspace.getLeaf().openFile(exportFile);
      }
    } catch (err) {
      new import_obsidian5.Notice("Failed to export highlights.");
      console.error(err);
    }
  }
  async copyAsQuote(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian5.Notice("No text selected.");
      return;
    }
    const quotedText = snippet.split("\n").map((l) => `> ${l}`).join("\n");
    let quote = this.settings.quoteTemplate.replace("{{text}}", quotedText).replace("{{file}}", view.file.basename).replace("{{path}}", view.file.path).replace("{{date}}", window.moment ? window.moment().format("YYYY-MM-DD") : (/* @__PURE__ */ new Date()).toISOString().split("T")[0]);
    await navigator.clipboard.writeText(quote);
    new import_obsidian5.Notice("Copied as quote!");
    sel == null ? void 0 : sel.removeAllRanges();
  }
  async applyColorHighlight(view, color, autoTag = "") {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim())
      return;
    const scrollPos = getScroll(view);
    await this.saveUndoState(view.file);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian5.Notice("Could not locate selection.");
      return;
    }
    await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, "color", color, autoTag);
    this.restoreScroll(view, scrollPos);
    sel == null ? void 0 : sel.removeAllRanges();
    new import_obsidian5.Notice("Highlighted!");
  }
  // Reading progress
  saveReadingProgress() {
    const view = this.getActiveReadingView();
    if (!view || !view.file)
      return;
    const pos = getScroll(view);
    if (pos && pos.y > 0) {
      this.settings.readingPositions[view.file.path] = pos.y;
      this.saveSettings();
    }
  }
  async resumeReading(view) {
    const pos = this.settings.readingPositions[view.file.path];
    if (pos) {
      applyScroll(view, { y: pos });
      new import_obsidian5.Notice("Resumed reading position.");
    } else {
      new import_obsidian5.Notice("No saved position for this file.");
    }
  }
  // Activate navigator view
  async activateNavigatorView() {
    const existing = this.app.workspace.getLeavesOfType(HIGHLIGHT_NAVIGATOR_VIEW);
    if (existing.length) {
      this.app.workspace.revealLeaf(existing[0]);
      return;
    }
    const leaf = this.app.workspace.getRightLeaf(false);
    await leaf.setViewState({
      type: HIGHLIGHT_NAVIGATOR_VIEW,
      active: true
    });
    this.app.workspace.revealLeaf(leaf);
  }
  async applyMarkdownModification(file, raw, start, end, mode, payload = "", autoTag = "") {
    let expandedStart = start;
    let expandedEnd = end;
    let expanded = true;
    while (expanded) {
      expanded = false;
      const preceding = raw.substring(0, expandedStart);
      const matchBack = preceding.match(/(<mark[^>]*>|\*\*|==|~~|\*|_|\[\[|\[)$/);
      if (matchBack) {
        expandedStart -= matchBack[0].length;
        expanded = true;
      }
      const following = raw.substring(expandedEnd);
      const matchForward = following.match(/^(<\/mark>|\*\*|==|~~|\*|_|\]\]|\]\([^)]+\))/);
      if (matchForward) {
        expandedEnd += matchForward[0].length;
        expanded = true;
      }
    }
    const selectedText = raw.substring(expandedStart, expandedEnd);
    const paragraphs = selectedText.split(/\n\s*\n/);
    let fullTag = "";
    if (mode === "tag" && payload) {
      const prefix = this.settings.defaultTagPrefix ? this.settings.defaultTagPrefix.trim() : "";
      const cleanPayload = payload.startsWith("#") ? payload.substring(1) : payload;
      if (prefix) {
        const cleanPrefix = prefix.startsWith("#") ? prefix.substring(1) : prefix;
        fullTag = `#${cleanPrefix} #${cleanPayload}`;
      } else {
        fullTag = `#${cleanPayload}`;
      }
    } else if ((mode === "highlight" || mode === "color") && this.settings.defaultTagPrefix) {
      const autoTagSetting = this.settings.defaultTagPrefix.trim();
      if (autoTagSetting) {
        const cleanTag = autoTagSetting.startsWith("#") ? autoTagSetting.substring(1) : autoTagSetting;
        fullTag = `#${cleanTag}`;
      }
    }
    if (autoTag) {
      const cleanAutoTag = autoTag.startsWith("#") ? autoTag : `#${autoTag}`;
      fullTag = fullTag ? `${fullTag} ${cleanAutoTag}` : cleanAutoTag;
    }
    const processedParagraphs = paragraphs.map((paragraph) => {
      if (!paragraph.trim())
        return paragraph;
      const lines = paragraph.split("\n");
      const processedLines = lines.map((line) => {
        let cleanLine = line.replace(/<mark[^>]*>/g, "").replace(/<\/mark>/g, "");
        if (mode === "highlight" || mode === "color" || mode === "tag") {
          cleanLine = cleanLine.split("==").join("");
        } else if (mode === "bold") {
          cleanLine = cleanLine.split("**").join("");
        } else if (mode === "italic") {
          cleanLine = cleanLine.split("*").join("");
        } else if (mode === "remove") {
          cleanLine = cleanLine.split("==").join("");
        }
        if (mode === "remove") {
          return cleanLine;
        }
        const matchIndent = cleanLine.match(/^(\s*)/);
        const indent = matchIndent ? matchIndent[0] : "";
        const contentAfterIndent = cleanLine.substring(indent.length);
        const prefixRegex = /^((?:#{1,6}\s+)|(?:[-*+]\s+)|(?:\d+\.\s+)|(?:>\s+)|(?:-\s\[[ x]\]\s+))/;
        const matchPrefix = contentAfterIndent.match(prefixRegex);
        let prefix = "";
        let content = contentAfterIndent;
        if (matchPrefix) {
          prefix = matchPrefix[0];
          content = contentAfterIndent.substring(prefix.length);
        }
        const tagStr = fullTag ? `${fullTag} ` : "";
        let wrappedContent = content;
        if (mode === "highlight" || mode === "tag") {
          if (this.settings.enableColorHighlighting && this.settings.highlightColor) {
            wrappedContent = `<mark style="background: ${this.settings.highlightColor}; color: black;">${content}</mark>`;
          } else {
            wrappedContent = `==${content}==`;
          }
        } else if (mode === "color") {
          wrappedContent = `<mark style="background: ${payload}; color: black;">${content}</mark>`;
        }
        return `${indent}${prefix}${tagStr}${wrappedContent}`;
      });
      return processedLines.join("\n");
    });
    const replaceBlock = processedParagraphs.join("\n\n");
    const newContent = raw.substring(0, expandedStart) + replaceBlock + raw.substring(expandedEnd);
    await this.app.vault.modify(file, newContent);
  }
  restoreScroll(view, pos) {
    requestAnimationFrame(() => {
      applyScroll(view, pos);
    });
  }
};
var ReadingHighlighterSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Reader Highlighter Tags Settings" });
    new import_obsidian5.Setting(containerEl).setName("Toolbar Position").setDesc("Choose where the floating toolbar should appear.").addDropdown((dropdown) => dropdown.addOption("text", "Next to text").addOption("top", "Fixed at Top Center").addOption("bottom", "Fixed at Bottom Center").addOption("left", "Fixed Left Side").addOption("right", "Fixed Right Side (Default)").setValue(this.plugin.settings.toolbarPosition).onChange(async (value) => {
      this.plugin.settings.toolbarPosition = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Highlighting" });
    new import_obsidian5.Setting(containerEl).setName("Enable Color Highlighting").setDesc("Use HTML <mark> tags with specific colors instead of == syntax.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableColorHighlighting).onChange(async (value) => {
      this.plugin.settings.enableColorHighlighting = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableColorHighlighting) {
      new import_obsidian5.Setting(containerEl).setName("Highlight Color").setDesc("Hex code for the default highlight color.").addColorPicker((color) => color.setValue(this.plugin.settings.highlightColor || "#FFEE58").onChange(async (value) => {
        this.plugin.settings.highlightColor = value;
        await this.plugin.saveSettings();
      }));
    }
    new import_obsidian5.Setting(containerEl).setName("Enable Color Palette").setDesc("Show a palette of 5 colors in the toolbar for quick selection.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableColorPalette).onChange(async (value) => {
      this.plugin.settings.enableColorPalette = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    if (this.plugin.settings.enableColorPalette) {
      containerEl.createEl("h4", { text: "Color Palette" });
      this.plugin.settings.colorPalette.forEach((item, index) => {
        new import_obsidian5.Setting(containerEl).setName(`Color ${index + 1}: ${item.name}`).addColorPicker((color) => color.setValue(item.color).onChange(async (value) => {
          this.plugin.settings.colorPalette[index].color = value;
          await this.plugin.saveSettings();
        })).addText((text) => text.setPlaceholder("Auto-tag (optional)").setValue(item.tag).onChange(async (value) => {
          this.plugin.settings.colorPalette[index].tag = value;
          await this.plugin.saveSettings();
        }));
      });
    }
    containerEl.createEl("h3", { text: "Tags" });
    new import_obsidian5.Setting(containerEl).setName("Default Tag Prefix").setDesc("Automatically add this tag to every highlight (e.g., 'book').").addText((text) => text.setPlaceholder("book").setValue(this.plugin.settings.defaultTagPrefix).onChange(async (value) => {
      this.plugin.settings.defaultTagPrefix = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Smart Tag Suggestions").setDesc("Suggest tags based on recent usage, folder, and frontmatter.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSmartTagSuggestions).onChange(async (value) => {
      this.plugin.settings.enableSmartTagSuggestions = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Quote Template" });
    new import_obsidian5.Setting(containerEl).setName("Quote Format").setDesc("Template for copying text as quote. Variables: {{text}}, {{file}}, {{path}}, {{date}}").addTextArea((text) => text.setValue(this.plugin.settings.quoteTemplate).onChange(async (value) => {
      this.plugin.settings.quoteTemplate = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Annotations" });
    new import_obsidian5.Setting(containerEl).setName("Enable Annotations").setDesc("Add comments to selections as footnotes.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAnnotations).onChange(async (value) => {
      this.plugin.settings.enableAnnotations = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Show Annotation Button").setDesc("Show the annotation button in the toolbar.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showAnnotationButton).onChange(async (value) => {
      this.plugin.settings.showAnnotationButton = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Reading Progress" });
    new import_obsidian5.Setting(containerEl).setName("Track Reading Progress").setDesc("Remember scroll position when leaving a file.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableReadingProgress).onChange(async (value) => {
      this.plugin.settings.enableReadingProgress = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Clear Reading Positions").setDesc(`Currently tracking ${Object.keys(this.plugin.settings.readingPositions).length} file(s).`).addButton((button) => button.setButtonText("Clear All").onClick(async () => {
      this.plugin.settings.readingPositions = {};
      await this.plugin.saveSettings();
      new import_obsidian5.Notice("Reading positions cleared.");
      this.display();
    }));
    containerEl.createEl("h3", { text: "Toolbar Buttons" });
    new import_obsidian5.Setting(containerEl).setName("Show Tag Button").addToggle((toggle) => toggle.setValue(this.plugin.settings.showTagButton).onChange(async (value) => {
      this.plugin.settings.showTagButton = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Show Quote Button").addToggle((toggle) => toggle.setValue(this.plugin.settings.showQuoteButton).onChange(async (value) => {
      this.plugin.settings.showQuoteButton = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Show Remove Button").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRemoveButton).onChange(async (value) => {
      this.plugin.settings.showRemoveButton = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Mobile & UX" });
    new import_obsidian5.Setting(containerEl).setName("Haptic Feedback").setDesc("Vibrate slightly on success (Mobile only).").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableHaptics).onChange(async (value) => {
      this.plugin.settings.enableHaptics = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian5.Setting(containerEl).setName("Show Button Tooltips").setDesc("Show tooltips when hovering over toolbar buttons.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showTooltips).onChange(async (value) => {
      this.plugin.settings.showTooltips = value;
      await this.plugin.saveSettings();
    }));
  }
};
