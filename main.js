/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.js
var main_exports = {};
__export(main_exports, {
  default: () => ReadingHighlighterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/ui/FloatingManager.js
var import_obsidian = require("obsidian");
var FloatingManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
    this.containerEl = null;
    this.highlightBtn = null;
    this.tagBtn = null;
    this.removeBtn = null;
    this._handlers = [];
  }
  load() {
    this.createElements();
    this.registerEvents();
  }
  unload() {
    var _a;
    (_a = this.containerEl) == null ? void 0 : _a.remove();
    this.containerEl = null;
    this._handlers.forEach((cleanup) => cleanup());
    this._handlers = [];
  }
  createElements() {
    if (this.containerEl)
      return;
    this.containerEl = document.createElement("div");
    this.containerEl.addClass("reading-highlighter-float-container");
    this.highlightBtn = this.createButton("highlighter", "Subrayar selecci\xF3n");
    this.tagBtn = this.createButton("tag", "Etiquetar selecci\xF3n");
    this.removeBtn = this.createButton("minus", "Eliminar subrayado");
    this.removeBtn.addClass("reading-highlighter-remove-btn");
    this.containerEl.appendChild(this.highlightBtn);
    this.containerEl.appendChild(this.tagBtn);
    this.containerEl.appendChild(this.removeBtn);
    document.body.appendChild(this.containerEl);
  }
  createButton(iconName, label) {
    const btn = document.createElement("button");
    (0, import_obsidian.setIcon)(btn, iconName);
    btn.setAttribute("aria-label", label);
    btn.addClass("reading-highlighter-btn");
    return btn;
  }
  registerEvents() {
    const preventFocus = (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
    };
    const attachAction = (btn, actionInfo) => {
      const handler = (evt) => {
        preventFocus(evt);
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.getMode() === "preview") {
          this.plugin[actionInfo](view);
        }
        this.hide();
      };
      btn.addEventListener("mousedown", handler);
      btn.addEventListener("touchstart", handler, { passive: false });
    };
    if (this.highlightBtn)
      attachAction(this.highlightBtn, "highlightSelection");
    if (this.tagBtn)
      attachAction(this.tagBtn, "tagSelection");
    if (this.removeBtn)
      attachAction(this.removeBtn, "removeHighlightSelection");
  }
  handleSelection() {
    var _a;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view || view.getMode() !== "preview") {
      this.hide();
      return;
    }
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (snippet.trim() && sel && !sel.isCollapsed && sel.rangeCount > 0) {
      const range = sel.getRangeAt(0);
      const rect = range.getBoundingClientRect();
      this.show(rect);
    } else {
      this.hide();
    }
  }
  show(rect) {
    if (!this.containerEl || !rect)
      return;
    this.containerEl.style.display = "flex";
    this.containerEl.style.top = "";
    this.containerEl.style.bottom = "";
    this.containerEl.style.left = "";
    this.containerEl.style.right = "";
    this.containerEl.style.transform = "";
    this.containerEl.removeClass("reading-highlighter-vertical");
    const pos = this.plugin.settings.toolbarPosition || "text";
    if (pos === "text") {
      const containerHeight = 40;
      const containerWidth = 140;
      let top = rect.top - containerHeight - 10;
      let left = rect.left + rect.width / 2 - containerWidth / 2;
      if (top < 10)
        top = rect.bottom + 10;
      if (left < 10)
        left = 10;
      if (left + containerWidth > window.innerWidth - 10)
        left = window.innerWidth - containerWidth - 10;
      this.containerEl.style.top = `${top}px`;
      this.containerEl.style.left = `${left}px`;
    } else if (pos === "top") {
      this.containerEl.style.top = "80px";
      this.containerEl.style.left = "50%";
      this.containerEl.style.transform = "translateX(-50%)";
    } else if (pos === "bottom") {
      this.containerEl.style.bottom = "100px";
      this.containerEl.style.left = "50%";
      this.containerEl.style.transform = "translateX(-50%)";
    } else if (pos === "left") {
      this.containerEl.style.top = "50%";
      this.containerEl.style.left = "10px";
      this.containerEl.style.transform = "translateY(-50%)";
      this.containerEl.addClass("reading-highlighter-vertical");
    } else if (pos === "right") {
      this.containerEl.style.top = "50%";
      this.containerEl.style.right = "10px";
      this.containerEl.style.transform = "translateY(-50%)";
      this.containerEl.addClass("reading-highlighter-vertical");
    }
  }
  hide() {
    if (this.containerEl) {
      this.containerEl.style.display = "none";
    }
  }
};

// src/core/SelectionLogic.js
var SelectionLogic = class {
  constructor(app) {
    this.app = app;
  }
  async locateSelection(processedFile, view, selectionSnippet, context = null, occurrenceIndex = 0) {
    const file = view.file;
    const raw = await this.app.vault.read(file);
    let candidates = this.findAllCandidates(raw, selectionSnippet);
    if (candidates.length === 0) {
      candidates = this.findCandidatesStripped(raw, selectionSnippet);
    }
    if (candidates.length === 0)
      return null;
    if (context) {
      const cleanContext = context.replace(/\s+/g, " ").trim();
      candidates = candidates.map((cand) => {
        let blockStart = raw.lastIndexOf("\n", cand.start);
        if (blockStart === -1)
          blockStart = 0;
        let blockEnd = raw.indexOf("\n", cand.end);
        if (blockEnd === -1)
          blockEnd = raw.length;
        const sourceBlock = raw.substring(blockStart, blockEnd).replace(/\s+/g, " ").trim();
        const score = this.calculateSimilarity(sourceBlock, cleanContext);
        return { ...cand, score };
      });
      const bestScore = Math.max(...candidates.map((c) => c.score));
      const threshold = bestScore * 0.85;
      const validCandidates = candidates.filter((c) => c.score >= threshold);
      if (occurrenceIndex >= 0 && occurrenceIndex < validCandidates.length) {
        const chosen = validCandidates[occurrenceIndex];
        return { raw, start: chosen.start, end: chosen.end };
      }
      if (validCandidates.length > 0) {
        return { raw, start: validCandidates[0].start, end: validCandidates[0].end };
      }
    }
    return { raw, start: candidates[0].start, end: candidates[0].end };
  }
  findAllCandidates(text, snippet) {
    const escaped = snippet.trim().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const pattern = escaped.replace(/\s+/g, "\\s+");
    const regex = new RegExp(pattern, "g");
    const candidates = [];
    let match;
    while ((match = regex.exec(text)) !== null) {
      candidates.push({
        start: match.index,
        end: match.index + match[0].length,
        text: match[0]
      });
    }
    return candidates;
  }
  findCandidatesStripped(text, snippet) {
    const map = [];
    let strippedRaw = "";
    const tokenRegex = /(\[(?:[^\]]+)\]\([^)]+\))|(\[\[(?:[^\]]+)\]\])|(\*|_|==|~~|<[^>]+>)/g;
    let lastIndex = 0;
    let match;
    while ((match = tokenRegex.exec(text)) !== null) {
      for (let i = lastIndex; i < match.index; i++) {
        map.push(i);
        strippedRaw += text[i];
      }
      const fullMatch = match[0];
      if (match[1]) {
        const closingBracket = fullMatch.indexOf("](");
        if (closingBracket !== -1) {
          const linkTextStart = match.index + 1;
          const linkTextEnd = match.index + closingBracket;
          for (let i = linkTextStart; i < linkTextEnd; i++) {
            map.push(i);
            strippedRaw += text[i];
          }
        }
      } else if (match[2]) {
        const inner = fullMatch.substring(2, fullMatch.length - 2);
        const pipeIndex = inner.indexOf("|");
        let visibleStart, visibleEnd;
        if (pipeIndex !== -1) {
          visibleStart = match.index + 2 + pipeIndex + 1;
          visibleEnd = match.index + fullMatch.length - 2;
        } else {
          visibleStart = match.index + 2;
          visibleEnd = match.index + fullMatch.length - 2;
        }
        for (let i = visibleStart; i < visibleEnd; i++) {
          map.push(i);
          strippedRaw += text[i];
        }
      } else {
      }
      lastIndex = tokenRegex.lastIndex;
    }
    for (let i = lastIndex; i < text.length; i++) {
      map.push(i);
      strippedRaw += text[i];
    }
    const escaped = snippet.trim().replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const pattern = escaped.replace(/\s+/g, "\\s+");
    const regex = new RegExp(pattern, "g");
    const candidates = [];
    let strippedMatch;
    while ((strippedMatch = regex.exec(strippedRaw)) !== null) {
      const strippedStart = strippedMatch.index;
      const strippedEnd = strippedMatch.index + strippedMatch[0].length;
      const rawStart = map[strippedStart];
      let rawEnd;
      if (strippedEnd < map.length) {
        rawEnd = map[strippedEnd];
      } else {
        rawEnd = map[strippedEnd - 1] + 1;
      }
      candidates.push({
        start: rawStart,
        end: rawEnd,
        text: text.substring(rawStart, rawEnd)
      });
    }
    return candidates;
  }
  calculateSimilarity(source, target) {
    if (source === target)
      return 1e3;
    const sourceTokens = source.split(" ");
    const targetTokens = target.split(" ");
    const sSet = new Set(sourceTokens);
    const tSet = new Set(targetTokens);
    let intersection = 0;
    for (const t of tSet) {
      if (sSet.has(t))
        intersection++;
    }
    const union = (/* @__PURE__ */ new Set([...sourceTokens, ...targetTokens])).size;
    const jaccard = union === 0 ? 0 : intersection / union;
    const lenDiff = Math.abs(source.length - target.length);
    const lenMultiplier = 1 / (1 + lenDiff * 0.1);
    return jaccard * 0.7 + lenMultiplier * 0.3;
  }
};

// src/modals/TagSuggestModal.js
var import_obsidian2 = require("obsidian");
var TagSuggestModal = class extends import_obsidian2.Modal {
  constructor(plugin, onChoose) {
    super(plugin.app);
    this.plugin = plugin;
    this.onChoose = onChoose;
    this.selectedTags = /* @__PURE__ */ new Set();
    this.suggestions = [];
    this.query = "";
    this.suggestionEl = null;
    this.selectedContainer = null;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("reading-highlighter-tag-modal");
    contentEl.createEl("h2", { text: "Add Tags" });
    this.selectedContainer = contentEl.createDiv({ cls: "selected-tags-container" });
    this.updateSelectedView();
    const inputContainer = contentEl.createDiv({ cls: "tag-search-input-container" });
    const input = inputContainer.createEl("input", {
      type: "text",
      cls: "tag-search-input",
      attr: { placeholder: "Search or create tag..." }
    });
    setTimeout(() => input.focus(), 50);
    this.suggestionEl = contentEl.createDiv({ cls: "tag-suggestions-list" });
    const footer = contentEl.createDiv({ cls: "modal-footer" });
    const doneBtn = footer.createEl("button", { text: "Done", cls: "mod-cta" });
    doneBtn.onclick = () => this.submit();
    const tagCounts = this.app.metadataCache.getTags();
    this.allTags = Object.keys(tagCounts).map((t) => t.substring(1));
    input.addEventListener("input", (e) => {
      this.query = e.target.value;
      this.renderSuggestions(this.query);
    });
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        if (this.query.trim()) {
          this.toggleTag(this.query.trim());
          this.query = "";
          input.value = "";
          this.renderSuggestions("");
        }
      } else if (e.key === "Backspace" && !this.query) {
      }
    });
    this.renderSuggestions("");
  }
  renderSuggestions(query) {
    this.suggestionEl.empty();
    const cleanQuery = query.toLowerCase().replace(/\s+/g, "_");
    let matches = this.allTags.filter((t) => t.toLowerCase().includes(cleanQuery));
    const isExact = matches.some((t) => t.toLowerCase() === cleanQuery);
    if (cleanQuery && !isExact) {
      this.renderItem(cleanQuery, true);
    }
    matches.slice(0, 50).forEach((tag) => {
      if (!this.selectedTags.has(tag)) {
        this.renderItem(tag, false);
      }
    });
  }
  renderItem(tag, isNew) {
    const el = this.suggestionEl.createDiv({ cls: "suggestion-item" });
    el.createSpan({ text: isNew ? `#${tag}` : tag });
    if (isNew) {
      el.createSpan({ text: " (Create new)", cls: "suggestion-note" });
    }
    el.addEventListener("click", () => {
      this.toggleTag(tag);
      this.query = "";
      this.contentEl.querySelector(".tag-search-input").value = "";
      this.contentEl.querySelector(".tag-search-input").focus();
      this.renderSuggestions("");
    });
  }
  toggleTag(tag) {
    const cleanTag = tag.replace(/^#/, "").replace(/\s+/g, "_");
    if (this.selectedTags.has(cleanTag)) {
      this.selectedTags.delete(cleanTag);
    } else {
      this.selectedTags.add(cleanTag);
    }
    this.updateSelectedView();
  }
  updateSelectedView() {
    this.selectedContainer.empty();
    this.selectedTags.forEach((tag) => {
      const chip = this.selectedContainer.createDiv({ cls: "tag-chip" });
      chip.createSpan({ text: `#${tag}` });
      const close = chip.createSpan({ cls: "tag-chip-close", text: "\xD7" });
      close.onclick = (e) => {
        e.stopPropagation();
        this.toggleTag(tag);
      };
    });
  }
  submit() {
    const result = Array.from(this.selectedTags).map((t) => `#${t}`).join(" ");
    this.onChoose(result);
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/utils/dom.js
function getScroll(view) {
  var _a;
  return typeof ((_a = view.previewMode) == null ? void 0 : _a.getScroll) === "function" ? view.previewMode.getScroll() : getFallbackScroll(view);
}
function applyScroll(view, pos) {
  var _a;
  if (typeof ((_a = view.previewMode) == null ? void 0 : _a.applyScroll) === "function") {
    view.previewMode.applyScroll(pos);
  } else {
    setFallbackScroll(view, pos);
  }
}
function getFallbackScroll(view) {
  var _a, _b;
  const el = (_a = view.containerEl.querySelector(".markdown-reading-view")) != null ? _a : view.containerEl.querySelector(".markdown-preview-view");
  return { x: 0, y: (_b = el == null ? void 0 : el.scrollTop) != null ? _b : 0 };
}
function setFallbackScroll(view, { y }) {
  var _a;
  const el = (_a = view.containerEl.querySelector(".markdown-reading-view")) != null ? _a : view.containerEl.querySelector(".markdown-preview-view");
  if (el)
    el.scrollTop = y;
}

// src/main.js
var DEFAULT_SETTINGS = {
  toolbarPosition: "right",
  // text, top, bottom, left, right
  // highlightStyle removed
  enableColorHighlighting: false,
  highlightColor: "",
  // Default: None (Theme decides)
  defaultTagPrefix: "",
  enableHaptics: true,
  showTagButton: true,
  showRemoveButton: true,
  showQuoteButton: true
  // New
  // showColorButtons removed
};
var ReadingHighlighterPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.floatingManager = new FloatingManager(this);
    this.logic = new SelectionLogic(this.app);
    this.addSettingTab(new ReadingHighlighterSettingTab(this.app, this));
    this.addCommand({
      id: "highlight-selection-reading",
      name: "Highlight selection (Reading View)",
      checkCallback: (checking) => {
        const view = this.getActiveReadingView();
        if (!view)
          return false;
        if (checking)
          return true;
        this.highlightSelection(view);
        return true;
      }
    });
    this.registerDomEvent(document, "selectionchange", () => {
      this.floatingManager.handleSelection();
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.floatingManager.handleSelection();
      })
    );
    if (import_obsidian3.Platform.isMobile) {
      const btn = this.addRibbonIcon("highlighter", "Highlight Selection", () => {
        const view = this.getActiveReadingView();
        if (view)
          this.highlightSelection(view);
        else
          new import_obsidian3.Notice("Open a note in Reading View first.");
      });
      this.register(() => btn.remove());
    }
    this.floatingManager.load();
  }
  onunload() {
    this.floatingManager.unload();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.floatingManager.refresh();
  }
  getActiveReadingView() {
    const view = this.app.workspace.getActiveViewOfType(require("obsidian").MarkdownView);
    return view && view.getMode() === "preview" ? view : null;
  }
  getSelectionContext() {
    var _a;
    const sel = window.getSelection();
    if (!sel || sel.rangeCount === 0)
      return null;
    const range = sel.getRangeAt(0);
    let container = range.commonAncestorContainer;
    while (container && container.nodeType !== 1) {
      container = container.parentElement;
    }
    const viewContainer = (_a = this.getActiveReadingView()) == null ? void 0 : _a.containerEl;
    while (container && container !== viewContainer) {
      const tag = container.tagName.toLowerCase();
      if (["p", "li", "h1", "h2", "h3", "h4", "h5", "h6", "div", "blockquote", "pre"].includes(tag)) {
        return container;
      }
      container = container.parentElement;
    }
    if (container)
      return container;
    return null;
  }
  getSelectionOccurrence(view, contextElement) {
    if (!contextElement)
      return 0;
    const contextText = contextElement.innerText.trim();
    const tagName = contextElement.tagName.toLowerCase();
    const allElements = view.contentEl.querySelectorAll(tagName);
    let count = 0;
    let foundIndex = 0;
    for (let i = 0; i < allElements.length; i++) {
      const el = allElements[i];
      if (el.innerText.trim() === contextText) {
        if (el === contextElement) {
          foundIndex = count;
          break;
        }
        count++;
      }
    }
    return foundIndex;
  }
  async highlightSelection(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian3.Notice("No text selected.");
      return;
    }
    const scrollPos = getScroll(view);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian3.Notice("Could not locate selection in file.");
      return;
    }
    let mode = "highlight";
    let payload = "";
    if (this.settings.enableColorHighlighting && this.settings.highlightColor) {
      mode = "color";
      payload = this.settings.highlightColor;
    }
    await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, mode, payload);
    this.restoreScroll(view, scrollPos);
    sel == null ? void 0 : sel.removeAllRanges();
  }
  async tagSelection(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian3.Notice("No text selected.");
      return;
    }
    const scrollPos = getScroll(view);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian3.Notice("Could not locate selection in file.");
      return;
    }
    new TagSuggestModal(this, async (tag) => {
      var _a2;
      await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, "tag", tag);
      this.restoreScroll(view, scrollPos);
      (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
    }).open();
  }
  async removeHighlightSelection(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian3.Notice("Select highlighted text to remove.");
      return;
    }
    const scrollPos = getScroll(view);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian3.Notice("Could not locate selection in file.");
      return;
    }
    await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, "remove");
    new import_obsidian3.Notice("Highlighting removed.");
    this.restoreScroll(view, scrollPos);
    sel == null ? void 0 : sel.removeAllRanges();
  }
  async copyAsQuote(view) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim()) {
      new import_obsidian3.Notice("No text selected.");
      return;
    }
    const quote = snippet.split("\n").map((l) => `> ${l}`).join("\n");
    const link = `

[[${view.file.basename}]]`;
    await navigator.clipboard.writeText(quote + link);
    new import_obsidian3.Notice("Copied as quote!");
    sel == null ? void 0 : sel.removeAllRanges();
  }
  async applyColorHighlight(view, color) {
    var _a;
    const sel = window.getSelection();
    const snippet = (_a = sel == null ? void 0 : sel.toString()) != null ? _a : "";
    if (!snippet.trim())
      return;
    const scrollPos = getScroll(view);
    const contextEl = this.getSelectionContext();
    const contextText = contextEl ? contextEl.innerText : null;
    const occurrenceIndex = this.getSelectionOccurrence(view, contextEl);
    const result = await this.logic.locateSelection(view.file, view, snippet, contextText, occurrenceIndex);
    if (!result) {
      new import_obsidian3.Notice("Could not locate selection.");
      return;
    }
    await this.applyMarkdownModification(view.file, result.raw, result.start, result.end, "color", color);
    this.restoreScroll(view, scrollPos);
    sel == null ? void 0 : sel.removeAllRanges();
  }
  async applyMarkdownModification(file, raw, start, end, mode, payload = "") {
    let expandedStart = start;
    let expandedEnd = end;
    let expanded = true;
    while (expanded) {
      expanded = false;
      const preceding = raw.substring(0, expandedStart);
      const matchBack = preceding.match(/(<mark[^>]*>|\*\*|==|~~|\*|_|\[\[|\[)$/);
      if (matchBack) {
        expandedStart -= matchBack[0].length;
        expanded = true;
      }
      const following = raw.substring(expandedEnd);
      const matchForward = following.match(/^(<\/mark>|\*\*|==|~~|\*|_|\]\]|\]\([^)]+\))/);
      if (matchForward) {
        expandedEnd += matchForward[0].length;
        expanded = true;
      }
    }
    const selectedText = raw.substring(expandedStart, expandedEnd);
    const paragraphs = selectedText.split(/\n\s*\n/);
    let fullTag = "";
    if (mode === "tag" && payload) {
      const prefix = this.settings.defaultTagPrefix ? this.settings.defaultTagPrefix.trim() : "";
      const cleanPayload = payload.startsWith("#") ? payload.substring(1) : payload;
      if (prefix) {
        const cleanPrefix = prefix.startsWith("#") ? prefix.substring(1) : prefix;
        fullTag = `#${cleanPrefix} #${cleanPayload}`;
      } else {
        fullTag = `#${cleanPayload}`;
      }
    } else if ((mode === "highlight" || mode === "color") && this.settings.defaultTagPrefix) {
      const autoTag = this.settings.defaultTagPrefix.trim();
      if (autoTag) {
        const cleanTag = autoTag.startsWith("#") ? autoTag.substring(1) : autoTag;
        fullTag = `#${cleanTag}`;
      }
    }
    const processedParagraphs = paragraphs.map((paragraph) => {
      if (!paragraph.trim())
        return paragraph;
      const lines = paragraph.split("\n");
      const processedLines = lines.map((line) => {
        let cleanLine = line.replace(/<mark[^>]*>/g, "").replace(/<\/mark>/g, "");
        if (mode === "highlight" || mode === "color" || mode === "tag") {
          cleanLine = cleanLine.split("==").join("");
        } else if (mode === "bold") {
          cleanLine = cleanLine.split("**").join("");
        } else if (mode === "italic") {
          cleanLine = cleanLine.split("*").join("");
        } else if (mode === "remove") {
          cleanLine = cleanLine.split("==").join("");
        }
        if (mode === "remove") {
          return cleanLine;
        }
        const matchIndent = cleanLine.match(/^(\s*)/);
        const indent = matchIndent ? matchIndent[0] : "";
        const contentAfterIndent = cleanLine.substring(indent.length);
        const prefixRegex = /^((?:#{1,6}\s+)|(?:[-*+]\s+)|(?:\d+\.\s+)|(?:>\s+)|(?:-\s\[[ x]\]\s+))/;
        const matchPrefix = contentAfterIndent.match(prefixRegex);
        let prefix = "";
        let content = contentAfterIndent;
        if (matchPrefix) {
          prefix = matchPrefix[0];
          content = contentAfterIndent.substring(prefix.length);
        }
        const tagStr = fullTag ? `${fullTag} ` : "";
        let wrappedContent = content;
        if (mode === "highlight" || mode === "tag") {
          if (this.settings.enableColorHighlighting && this.settings.highlightColor) {
            wrappedContent = `<mark style="background: ${this.settings.highlightColor}; color: black;">${content}</mark>`;
          } else {
            wrappedContent = `==${content}==`;
          }
        } else if (mode === "color") {
          wrappedContent = `<mark style="background: ${payload}; color: black;">${content}</mark>`;
        }
        return `${indent}${prefix}${tagStr}${wrappedContent}`;
      });
      return processedLines.join("\n");
    });
    const replaceBlock = processedParagraphs.join("\n\n");
    const newContent = raw.substring(0, expandedStart) + replaceBlock + raw.substring(expandedEnd);
    await this.app.vault.modify(file, newContent);
  }
  restoreScroll(view, pos) {
    requestAnimationFrame(() => {
      applyScroll(view, pos);
    });
  }
};
var ReadingHighlighterSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Reader Highlighter Tags Settings" });
    new import_obsidian3.Setting(containerEl).setName("Toolbar Position").setDesc("Choose where the floating toolbar should appear.").addDropdown((dropdown) => dropdown.addOption("text", "Next to text").addOption("top", "Fixed at Top Center").addOption("bottom", "Fixed at Bottom Center").addOption("left", "Fixed Left Side").addOption("right", "Fixed Right Side (Default)").setValue(this.plugin.settings.toolbarPosition).onChange(async (value) => {
      this.plugin.settings.toolbarPosition = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Visuals & Workflow" });
    new import_obsidian3.Setting(containerEl).setName("Enable Color Highlighting").setDesc("Use HTML <mark> tags with specific colors. Overrides 'Highlight Style'.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableColorHighlighting).onChange(async (value) => {
      this.plugin.settings.enableColorHighlighting = value;
      await this.plugin.saveSettings();
      this.display();
    }));
    new import_obsidian3.Setting(containerEl).setName("Highlight Color").setDesc("Hex code for the highlight color (e.g. #FFEE58). Active when 'Enable Color Highlighting' is ON.").addColorPicker((color) => color.setValue(this.plugin.settings.highlightColor).onChange(async (value) => {
      this.plugin.settings.highlightColor = value;
      await this.plugin.saveSettings();
    })).addText((text) => text.setPlaceholder("#FFEE58").setValue(this.plugin.settings.highlightColor).onChange(async (value) => {
      this.plugin.settings.highlightColor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Default Tag Prefix").setDesc("Automatically nest tags (e.g., 'book'). Leave empty for no prefix. No need for slashes.").addText((text) => text.setPlaceholder("book").setValue(this.plugin.settings.defaultTagPrefix).onChange(async (value) => {
      this.plugin.settings.defaultTagPrefix = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Toolbar Buttons" });
    new import_obsidian3.Setting(containerEl).setName("Show Tag Button").addToggle((toggle) => toggle.setValue(this.plugin.settings.showTagButton).onChange(async (value) => {
      this.plugin.settings.showTagButton = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Show Quote Button").addToggle((toggle) => toggle.setValue(this.plugin.settings.showQuoteButton).onChange(async (value) => {
      this.plugin.settings.showQuoteButton = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Show Remove Button").addToggle((toggle) => toggle.setValue(this.plugin.settings.showRemoveButton).onChange(async (value) => {
      this.plugin.settings.showRemoveButton = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Mobile & UX" });
    new import_obsidian3.Setting(containerEl).setName("Haptic Feedback").setDesc("Vibrate slightly on success (Mobile only).").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableHaptics).onChange(async (value) => {
      this.plugin.settings.enableHaptics = value;
      await this.plugin.saveSettings();
    }));
  }
};
